// Generated by TinyPG v1.3 available at www.codeproject.com

#pragma warning disable CRR0026 // Unused member
#pragma warning disable CS0168 // Variable is declared but never used
#pragma warning disable IDE0044 // Add readonly modifier
#pragma warning disable CRR0052
#pragma warning disable CRR0044

using System;
using System.Collections.Generic;

namespace SpreadCommander.Common.Parsers.ConsoleScript
{
    #region Parser

    public partial class Parser 
    {
        private Scanner scanner;
        private ParseTree tree;
        
        public Parser(Scanner scanner)
        {
            this.scanner = scanner;
        }

        public ParseTree Parse(string input)
        {
            tree = new ParseTree();
            return Parse(input, tree);
        }

        public ParseTree Parse(string input, ParseTree tree)
        {
            scanner.Init(input);

            this.tree = tree;
            ParseStart(tree);
            tree.Skipped = scanner.Skipped;

            return tree;
        }

        private void ParseStart(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Start), "Start");
            parent.Nodes.Add(node);


            
            do {
                ParseCommand(node);
                tok = scanner.LookAhead(TokenType.INSERT, TokenType.VIEW, TokenType.FORMAT, TokenType.COMPUTED, TokenType.TABLE, TokenType.RELATION, TokenType.CONNECTION, TokenType.PARAMETER);
            } while (tok.Type == TokenType.INSERT
                || tok.Type == TokenType.VIEW
                || tok.Type == TokenType.FORMAT
                || tok.Type == TokenType.COMPUTED
                || tok.Type == TokenType.TABLE
                || tok.Type == TokenType.RELATION
                || tok.Type == TokenType.CONNECTION
                || tok.Type == TokenType.PARAMETER);

            
            tok = scanner.Scan(TokenType.EOF);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOF) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOF.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseCOMPUTED_RETURNTYPE(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.COMPUTED_RETURNTYPE), "COMPUTED_RETURNTYPE");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.STRING, TokenType.INTEGER, TokenType.DECIMAL, TokenType.DATETIME, TokenType.BOOLEAN);
            switch (tok.Type)
            {
                case TokenType.STRING:
                    tok = scanner.Scan(TokenType.STRING);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.STRING) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.STRING.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.INTEGER:
                    tok = scanner.Scan(TokenType.INTEGER);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.INTEGER) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.INTEGER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.DECIMAL:
                    tok = scanner.Scan(TokenType.DECIMAL);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.DECIMAL) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DECIMAL.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.DATETIME:
                    tok = scanner.Scan(TokenType.DATETIME);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.DATETIME) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DATETIME.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.BOOLEAN:
                    tok = scanner.Scan(TokenType.BOOLEAN);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.BOOLEAN) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BOOLEAN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseCommand(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Command), "Command");
            parent.Nodes.Add(node);


            
            tok = scanner.LookAhead(TokenType.INSERT, TokenType.VIEW, TokenType.FORMAT, TokenType.COMPUTED, TokenType.TABLE, TokenType.RELATION, TokenType.CONNECTION, TokenType.PARAMETER);
            switch (tok.Type)
            {
                case TokenType.INSERT:
                    ParseInsertFile(node);
                    break;
                case TokenType.VIEW:
                    ParseViewFile(node);
                    break;
                case TokenType.FORMAT:
                    ParseFormatCondition(node);
                    break;
                case TokenType.COMPUTED:
                    ParseComputedColumn(node);
                    break;
                case TokenType.TABLE:
                    ParseTable(node);
                    break;
                case TokenType.RELATION:
                    ParseRelation(node);
                    break;
                case TokenType.CONNECTION:
                    ParseConnection(node);
                    break;
                case TokenType.PARAMETER:
                    ParseParameter(node);
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            }

            
            tok = scanner.LookAhead(TokenType.SEMICOLON);
            if (tok.Type == TokenType.SEMICOLON)
            {
                tok = scanner.Scan(TokenType.SEMICOLON);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.SEMICOLON) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.SEMICOLON.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseInsertFile(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.InsertFile), "InsertFile");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.INSERT);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.INSERT) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.INSERT.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.Scan(TokenType.FILE);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.FILE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FILE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            ParseObjectName(node);

            
            tok = scanner.LookAhead(TokenType.WITH);
            if (tok.Type == TokenType.WITH)
            {

                
                tok = scanner.Scan(TokenType.WITH);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.WITH) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.WITH.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }

                
                do {
                    ParseProperty(node);
                    tok = scanner.LookAhead(TokenType.IDENT);
                } while (tok.Type == TokenType.IDENT);
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseViewFile(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.ViewFile), "ViewFile");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.VIEW);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.VIEW) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.VIEW.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.Scan(TokenType.FILE);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.FILE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FILE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            ParseObjectName(node);

            
            tok = scanner.LookAhead(TokenType.WITH);
            if (tok.Type == TokenType.WITH)
            {

                
                tok = scanner.Scan(TokenType.WITH);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.WITH) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.WITH.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }

                
                do {
                    ParseProperty(node);
                    tok = scanner.LookAhead(TokenType.IDENT);
                } while (tok.Type == TokenType.IDENT);
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseFormatCondition(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.FormatCondition), "FormatCondition");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.FORMAT);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.FORMAT) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FORMAT.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.LookAhead(TokenType.TABLE);
            if (tok.Type == TokenType.TABLE)
            {

                
                tok = scanner.Scan(TokenType.TABLE);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.TABLE) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.TABLE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }

                
                ParseTableName(node);
            }

            
            tok = scanner.LookAhead(TokenType.COLUMN);
            if (tok.Type == TokenType.COLUMN)
            {

                
                tok = scanner.Scan(TokenType.COLUMN);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.COLUMN) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COLUMN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }

                
                ParseColumnName(node);
            }

            
            tok = scanner.LookAhead(TokenType.FOR);
            if (tok.Type == TokenType.FOR)
            {

                
                tok = scanner.Scan(TokenType.FOR);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.FOR) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.FOR.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }

                
                ParseFormatFilter(node);
            }

            
            tok = scanner.Scan(TokenType.WITH);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.WITH) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.WITH.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            do {
                ParseProperty(node);
                tok = scanner.LookAhead(TokenType.IDENT);
            } while (tok.Type == TokenType.IDENT);

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseComputedColumn(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.ComputedColumn), "ComputedColumn");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.COMPUTED);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.COMPUTED) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMPUTED.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            tok = scanner.Scan(TokenType.COLUMN);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.COLUMN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COLUMN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            ParseColumnName(node);

            
            tok = scanner.LookAhead(TokenType.STRING, TokenType.INTEGER, TokenType.DECIMAL, TokenType.DATETIME, TokenType.BOOLEAN);
            if (tok.Type == TokenType.STRING
                || tok.Type == TokenType.INTEGER
                || tok.Type == TokenType.DECIMAL
                || tok.Type == TokenType.DATETIME
                || tok.Type == TokenType.BOOLEAN)
            {
                ParseCOMPUTED_RETURNTYPE(node);
            }

            
            tok = scanner.LookAhead(TokenType.IN);
            if (tok.Type == TokenType.IN)
            {

                
                tok = scanner.Scan(TokenType.IN);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.IN) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }

                
                ParseTableName(node);
            }

            
            tok = scanner.Scan(TokenType.COMPARE_EQUAL);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.COMPARE_EQUAL) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMPARE_EQUAL.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            ParsePropertyValue(node);

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseTable(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Table), "Table");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.TABLE);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.TABLE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.TABLE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            ParseTableName(node);

            
            tok = scanner.LookAhead(TokenType.WITH);
            if (tok.Type == TokenType.WITH)
            {

                
                tok = scanner.Scan(TokenType.WITH);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.WITH) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.WITH.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }

                
                do {
                    ParseProperty(node);
                    tok = scanner.LookAhead(TokenType.IDENT);
                } while (tok.Type == TokenType.IDENT);
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseRelation(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Relation), "Relation");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.RELATION);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.RELATION) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.RELATION.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            ParseRelationName(node);

            
            ParseTableWithColumns(node);

            
            tok = scanner.Scan(TokenType.DEFICE);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.DEFICE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DEFICE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            ParseTableWithColumns(node);

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseConnection(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Connection), "Connection");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.CONNECTION);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.CONNECTION) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CONNECTION.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            ParseConnectionName(node);

            
            tok = scanner.LookAhead(TokenType.WITH);
            if (tok.Type == TokenType.WITH)
            {

                
                tok = scanner.Scan(TokenType.WITH);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.WITH) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.WITH.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }

                
                do {
                    ParseProperty(node);
                    tok = scanner.LookAhead(TokenType.IDENT);
                } while (tok.Type == TokenType.IDENT);
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseParameter(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Parameter), "Parameter");
            parent.Nodes.Add(node);


            
            tok = scanner.Scan(TokenType.PARAMETER);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.PARAMETER) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PARAMETER.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            ParseParameterName(node);

            
            tok = scanner.LookAhead(TokenType.WITH);
            if (tok.Type == TokenType.WITH)
            {

                
                tok = scanner.Scan(TokenType.WITH);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.WITH) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.WITH.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }

                
                do {
                    ParseProperty(node);
                    tok = scanner.LookAhead(TokenType.IDENT);
                } while (tok.Type == TokenType.IDENT);
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseObjectName(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.ObjectName), "ObjectName");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.IDENT, TokenType.IDENT_BRACED, TokenType.IDENT_QUOTED, TokenType.IDENT_STRING, TokenType.IDENT_STRING2);
            switch (tok.Type)
            {
                case TokenType.IDENT:
                    tok = scanner.Scan(TokenType.IDENT);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.IDENT) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENT.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.IDENT_BRACED:
                    tok = scanner.Scan(TokenType.IDENT_BRACED);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.IDENT_BRACED) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENT_BRACED.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.IDENT_QUOTED:
                    tok = scanner.Scan(TokenType.IDENT_QUOTED);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.IDENT_QUOTED) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENT_QUOTED.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.IDENT_STRING:
                    tok = scanner.Scan(TokenType.IDENT_STRING);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.IDENT_STRING) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENT_STRING.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.IDENT_STRING2:
                    tok = scanner.Scan(TokenType.IDENT_STRING2);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.IDENT_STRING2) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENT_STRING2.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseColumnName(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.ColumnName), "ColumnName");
            parent.Nodes.Add(node);

            ParseObjectName(node);

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseTableName(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.TableName), "TableName");
            parent.Nodes.Add(node);

            ParseObjectName(node);

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseTableWithColumns(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.TableWithColumns), "TableWithColumns");
            parent.Nodes.Add(node);


            
            ParseTableName(node);

            
            tok = scanner.Scan(TokenType.BR_OPEN);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.BR_OPEN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BR_OPEN.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            do {

                
                ParseColumnName(node);

                
                tok = scanner.LookAhead(TokenType.COMMA);
                if (tok.Type == TokenType.COMMA)
                {
                    tok = scanner.Scan(TokenType.COMMA);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.COMMA) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                }
                tok = scanner.LookAhead(TokenType.IDENT, TokenType.IDENT_BRACED, TokenType.IDENT_QUOTED, TokenType.IDENT_STRING, TokenType.IDENT_STRING2);
            } while (tok.Type == TokenType.IDENT
                || tok.Type == TokenType.IDENT_BRACED
                || tok.Type == TokenType.IDENT_QUOTED
                || tok.Type == TokenType.IDENT_STRING
                || tok.Type == TokenType.IDENT_STRING2);

            
            tok = scanner.Scan(TokenType.BR_CLOSE);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.BR_CLOSE) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.BR_CLOSE.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseRelationName(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.RelationName), "RelationName");
            parent.Nodes.Add(node);

            ParseObjectName(node);

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseConnectionName(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.ConnectionName), "ConnectionName");
            parent.Nodes.Add(node);

            ParseObjectName(node);

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseParameterName(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.ParameterName), "ParameterName");
            parent.Nodes.Add(node);

            ParseObjectName(node);

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseFormatFilter(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.FormatFilter), "FormatFilter");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.IDENT_STRING, TokenType.IDENT_QUOTED, TokenType.IDENT_STRING2);
            switch (tok.Type)
            {
                case TokenType.IDENT_STRING:
                    tok = scanner.Scan(TokenType.IDENT_STRING);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.IDENT_STRING) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENT_STRING.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.IDENT_QUOTED:
                    tok = scanner.Scan(TokenType.IDENT_QUOTED);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.IDENT_QUOTED) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENT_QUOTED.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.IDENT_STRING2:
                    tok = scanner.Scan(TokenType.IDENT_STRING2);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.IDENT_STRING2) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENT_STRING2.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParsePropertyName(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.PropertyName), "PropertyName");
            parent.Nodes.Add(node);

            tok = scanner.Scan(TokenType.IDENT);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IDENT) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENT.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParsePropertyValue(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.PropertyValue), "PropertyValue");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.IDENT, TokenType.IDENT_STRING, TokenType.IDENT_QUOTED, TokenType.IDENT_STRING2);
            switch (tok.Type)
            {
                case TokenType.IDENT:
                    tok = scanner.Scan(TokenType.IDENT);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.IDENT) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENT.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.IDENT_STRING:
                    tok = scanner.Scan(TokenType.IDENT_STRING);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.IDENT_STRING) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENT_STRING.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.IDENT_QUOTED:
                    tok = scanner.Scan(TokenType.IDENT_QUOTED);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.IDENT_QUOTED) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENT_QUOTED.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                case TokenType.IDENT_STRING2:
                    tok = scanner.Scan(TokenType.IDENT_STRING2);
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.IDENT_STRING2) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENT_STRING2.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                        return;
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found.", 0x0002, 0, tok.StartPos, tok.StartPos, tok.Length));
                    break;
            }

            parent.Token.UpdateRange(node.Token);
        }

        private void ParseProperty(ParseNode parent)
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Property), "Property");
            parent.Nodes.Add(node);


            
            ParsePropertyName(node);

            
            tok = scanner.Scan(TokenType.COMPARE_EQUAL);
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.COMPARE_EQUAL) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMPARE_EQUAL.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                return;
            }

            
            ParsePropertyValue(node);

            
            tok = scanner.LookAhead(TokenType.COMMA);
            if (tok.Type == TokenType.COMMA)
            {
                tok = scanner.Scan(TokenType.COMMA);
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.COMMA) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMMA.ToString(), 0x1001, 0, tok.StartPos, tok.StartPos, tok.Length));
                    return;
                }
            }

            parent.Token.UpdateRange(node.Token);
        }


    }

    #endregion Parser
}